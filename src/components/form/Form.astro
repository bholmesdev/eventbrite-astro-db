---
import type { HTMLAttributes } from "astro/types";
import type * as validators from "./validators";

type Props = Omit<HTMLAttributes<"form">, "name" | "method"> & {
  name: keyof typeof validators;
};

const props = Astro.props;
---

<s-form>
  <form {...props} method="POST" data-target="s-form.form">
    <slot />
  </form>
</s-form>

<script>
  import { controller, target, targets } from "@github/catalyst";
  import { validateForm } from "simple:form";
  import * as validators from "./validators";
  import { navigate } from "astro:transitions/client";
  import { formContext, type FormContext } from "./ctx";
  import { atom } from "nanostores";

  @controller
  class SFormElement extends HTMLElement {
    @target form!: HTMLFormElement;
    @targets inputs!: HTMLElement[];

    #context: FormContext;

    constructor() {
      super();
      if (!(this.form.name in validators)) {
        throw new Error(`Validator "${this.form.name}" not found`);
      }
      this.#context = formContext.provide(this, {
        status: atom("idle"),
        validator:
          validators[this.form.name as keyof typeof validators].validator,
      })!;
    }

    connectedCallback() {
      this.form.addEventListener("submit", this.submitForm.bind(this));
    }

    async submitForm(e: SubmitEvent) {
      const { status, validator } = this.#context;
      e.preventDefault();
      e.stopPropagation();
      const formData = new FormData(this.form);
      status.set("validating");
      const parsed = await validateForm({
        formData,
        validator,
      });
      if (parsed.data) {
        navigate(this.form.action, { formData });
        document.addEventListener(
          "astro:after-preparation",
          () => {
            status.set("idle");
          },
          {
            once: true,
          }
        );
        return;
      }
      status.set("errored");
    }
  }
</script>
