---
import type { HTMLAttributes } from "astro/types";
import type * as validators from "./validators";

type Props = Omit<HTMLAttributes<"form">, "name" | "method"> & {
  name: keyof typeof validators;
};

const { name, ...formProps } = Astro.props;
---

<s-form>
  <form {name} {...formProps} method="POST" data-target="s-form.form">
    <slot />
  </form>
</s-form>

<script>
  import { controller, target, targets } from "@github/catalyst";
  import { validateForm } from "simple:form";
  import * as validators from "./validators";
  import { navigate } from "astro:transitions/client";
  import { formContext, type FormContext } from "./ctx";
  import { atom } from "nanostores";

  @controller
  class SFormElement extends HTMLElement {
    @target form!: HTMLFormElement;
    @targets inputs!: HTMLElement[];

    #status: FormContext["status"];
    #validator: FormContext["validator"];

    constructor() {
      super();
      if (!(this.form.name in validators)) {
        throw new Error(`Validator "${this.form.name}" not found`);
      }
      this.#status = atom("idle");
      this.#validator =
        validators[this.form.name as keyof typeof validators].validator;

      formContext.provide(this, {
        validator: this.#validator,
        status: this.#status,
      });
    }

    connectedCallback() {
      this.form.addEventListener("submit", this.submitForm.bind(this));
    }

    async submitForm(e: SubmitEvent) {
      e.preventDefault();
      e.stopPropagation();
      const formData = new FormData(this.form);
      this.#status.set("validating");
      const parsed = await validateForm({
        formData,
        validator: this.#validator,
      });
      if (parsed.data) {
        navigate(this.form.action, { formData });
        document.addEventListener(
          "astro:after-preparation",
          () => {
            this.#status.set("idle");
          },
          {
            once: true,
          }
        );
        return;
      }
      this.#status.set("errored");
    }
  }
</script>
