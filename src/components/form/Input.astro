---
import type { HTMLAttributes } from "astro/types";

type Props = HTMLAttributes<"input">;

const props = Astro.props;
---

<s-input data-targets="s-form.inputs">
  <input
    {...props}
    data-target="s-input.input"
    data-action="input:s-input#validate blur:s-input#validate"
  />
</s-input>

<style>
  input {
    width: 100%;
  }
  [data-errored] input {
    outline: 1px solid var(--red-6);
  }
</style>

<script>
  import { controller, target, attr } from "@github/catalyst";
  import { html, render } from "@github/jtml";
  import { type FormContext, formContext } from "./ctx";

  @controller
  class SInputElement extends HTMLElement {
    @attr dirty = false;
    @attr errored = false;
    @target input!: HTMLInputElement;

    #formContext: FormContext;

    constructor() {
      super();
      const context = formContext.use(this);
      if (!context) {
        throw new Error(
          "Form context not found. Did you use Input outside of a Form?"
        );
      }
      this.#formContext = context;
    }

    connectedCallback() {
      this.#formContext.status.subscribe((status) => {
        if (status === "errored") {
          this.dirty = true;
          this.validate(new Event("input"));
        }
      });
    }

    validate(e: Event) {
      if (e.type === "input" && !this.dirty) return;

      const value = this.input.value;
      if (value === "" && !this.dirty) return;
      if (e.type === "blur") this.dirty = true;

      const inputValidator = this.#formContext.validator[this.input.name];
      if (!inputValidator) {
        throw new Error(
          `No validator found for input with name ${this.input.name}`
        );
      }
      const res = inputValidator.safeParse(value);
      const errors = res.success ? [] : res.error.format()._errors;
      this.errored = errors.length > 0;

      render(
        html`${errors.length
          ? errors.map((e) => html`<p class="error">${e}</p>`)
          : null}`,
        this
      );
    }
  }
</script>
